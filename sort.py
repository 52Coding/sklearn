# -*- coding: utf-8 -*-
"""sort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/101wuCBMt6JQiPwKvRh7UTu9Jb6l77Tz5

时间复杂度；

空间复杂度；

稳定性：同值顺序排序过程中是否会变；
"""

# bubble
# (n-1)*(n-1)次循环
# 每一趟能得到一个有序极值
def bubbleSort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr)-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
  
print(bubbleSort([3,1,4,5,2,7]))

# 选择
# (n-1)*(n-1)次循环
# 每一趟得到一个极值索引，视情况交换位置
def selectionSort(arr):
    for i in range(len(arr) - 1):
        # 记录最小数的索引
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
        # i 不是最小数时，将 i 和最小数进行交换
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr

print(selectionSort([3,1,4,5,2,7]))

# 插入
# n*(N-1)次循环
def insertionSort(arr):
    for i in range(len(arr)):
        preIndex = i-1
        current = arr[i] # 缓存放插值，视情况左边交换
        while preIndex >= 0 and arr[preIndex] > current:
            arr[preIndex+1] = arr[preIndex]
            preIndex-=1
        arr[preIndex+1] = current
        print(i, arr)
    return arr
  
print(insertionSort([3,1,4,5,2,7])) 

# 314527
# 134527
# 134527
# 134527
# 134257 132457 123457

# 希尔
# 关键字： 远端、间隔、最后间隔为1
# 间隔gap逐渐缩小，当为1时即为 普通插入排序
def shellSort(arr):
    import math
    gap=1
    while(gap < len(arr)/3):
        gap = gap*3+1
    while gap > 0:
        for i in range(gap,len(arr)):
            temp = arr[i]
            j = i-gap
            while j >=0 and arr[j] > temp:
                arr[j+gap]=arr[j]
                j-=gap  ##################
            arr[j+gap] = temp
            print(i, ":",arr)
        gap = math.floor(gap/3)
    return arr

print(shellSort([3,1,4,5,2,7]))

# 归并 
# 子序列有序后合并
# 循环调用自身（递归）
def mergeSort(arr):
    import math
    if(len(arr)<2):
        return arr
    middle = math.floor(len(arr)/2)
    left, right = arr[0:middle], arr[middle:]
    return merge(mergeSort(left), mergeSort(right))  ###############

def merge(left,right):
    print("merge:", left, right)
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0));
        else:
            result.append(right.pop(0));
        print(result)
    while left:
        result.append(left.pop(0));
    while right:
        result.append(right.pop(0));
    return result

print(mergeSort([3,1,4,5,2,7]))

# 快速
# 待定：设置基准 + 分区
# 分区：定基准，小的在左大的在右
# 循环调用自身（递归）
def quickSort(arr, left=None, right=None):
    left = 0 if not isinstance(left,(int, float)) else left
    right = len(arr)-1 if not isinstance(right,(int, float)) else right
    if left < right:
        partitionIndex = partition(arr, left, right)
        quickSort(arr, left, partitionIndex-1)
        quickSort(arr, partitionIndex+1, right)
    return arr

def partition(arr, left, right):
    pivot = left
    index = pivot+1
    i = index
    while  i <= right:
        if arr[i] < arr[pivot]:
            swap(arr, i, index)
            index+=1
            print(pivot, index, i, arr)
        i+=1
    swap(arr,pivot,index-1)
    print(arr)
    return index-1

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]
    
print(quickSort([3,1,4,5,2,7]))

# 堆
# 快速冒泡选择堆 ~  待定
# 算法复杂度（耗时）： 1 < logN < N < NlogN < N平方 （代入256，2的8次方）

def buildMaxHeap(arr):
    import math
    for i in range(math.floor(len(arr)/2),-1,-1):
        heapify(arr,i)

def heapify(arr, i):
    left = 2*i+1
    right = 2*i+2
    largest = i
    if left < arrLen and arr[left] > arr[largest]:
        largest = left
    if right < arrLen and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        swap(arr, i, largest)
        heapify(arr, largest)

def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def heapSort(arr):
    global arrLen
    arrLen = len(arr)
    buildMaxHeap(arr)
    for i in range(len(arr)-1,0,-1):
        swap(arr,0,i)
        arrLen -=1
        heapify(arr, 0)
    return arr

print(heapSort([3,1,4,5,2,7]))

# 计数 

def countingSort(arr, maxValue):
    bucketLen = maxValue+1
    bucket = [0]*bucketLen
    sortedIndex =0
    arrLen = len(arr)
    for i in range(arrLen):
        if not bucket[arr[i]]:
            bucket[arr[i]]=0
        bucket[arr[i]]+=1
    print(bucket) ## 神似字典计数
    
    # 依序遍历每个桶，桶中值相同
    for j in range(bucketLen):
        while bucket[j]>0:
            arr[sortedIndex] = j
            sortedIndex+=1
            bucket[j]-=1
    return arr
  
print(countingSort([3,1,1,4,5,2,7], 10))